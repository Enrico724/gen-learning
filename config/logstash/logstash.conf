input {
  kafka {
    bootstrap_servers => '${KAFKA_HOSTS}'
    # Ora ascoltiamo su tutti e quattro i topic
    topics => ["book-structures", "enriched-prompts", "enriched-paragraphs", "paragraphs", "generated-books"]
    codec => 'json'
    # È buona norma specificare un group_id per il consumer Kafka
    group_id => "logstash-indexer-group"
    decorate_events => true
  }
}

filter {
  # Controlliamo il nome del topic da cui proviene il messaggio.
  # Questo metadato viene aggiunto automaticamente dall'input Kafka.
  if [@metadata][kafka][topic] == "book-structures" {
    mutate {
      add_field => { 
        "[@metadata][target_index]" => "book-structures"
        "[@metadata][document_id]" => "%{job_id}"
      }
    }
  } 
  else if [@metadata][kafka][topic] == "enriched-prompts" {
    mutate {
      add_field => {
        "[@metadata][target_index]" => "enriched-prompts"
        "[@metadata][document_id]" => "%{job_id}"
      }
    }
  }
  else if [@metadata][kafka][topic] == "enriched-paragraphs" {
    mutate {
      add_field => { 
        "[@metadata][target_index]" => "enriched-paragraphs"
        "[@metadata][document_id]" => "%{paragraph_id}"
      }
    }
  }
  else if [@metadata][kafka][topic] == "paragraphs" {
    mutate {
      add_field => {
        "[@metadata][target_index]" => "paragraphs"
        "[@metadata][document_id]" => "%{paragraph_id}"
      }
    }
  }
  else if [@metadata][kafka][topic] == "generated-books" {
    fingerprint {
      source => ["titolo_libro"]
      target => "book_title_hash"
      method => "SHA256"
    }
    mutate {
      add_field => {
        "[@metadata][target_index]" => "generated-books"
        "[@metadata][document_id]" => "%{book_title_hash}"
      }
    }
  }
}

output {
  elasticsearch {
    # Il nome dell'indice è ora dinamico, basato sul valore
    # che abbiamo impostato nel blocco filter.
    index => "%{[@metadata][target_index]}"
    
    # Anche l'ID del documento è dinamico.
    document_id => "%{[@metadata][document_id]}"
    
    # Le credenziali e la configurazione di connessione rimangono invariate.
    hosts=> "${ELASTIC_HOSTS}"
    user=> "${ELASTIC_USER}"
    password=> "${ELASTIC_PASSWORD}"
    cacert=> "certs/ca/ca.crt"
  }
  
  # Teniamo stdout per il debug durante lo sviluppo
  stdout {
    codec => rubydebug { metadata => true }
  } 
}